<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bookmark Workbench</title>
    <style>
      :root {
        --bg: #f1f5f9;
        --surface: #ffffff;
        --text: #0f172a;
        --muted: #64748b;
        --line: #cbd5e1;
        --accent: #0369a1;
        --accent-2: #0ea5e9;
        --danger: #b91c1c;
        --row-h: 34px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        color: var(--text);
        background: radial-gradient(circle at 20% -20%, #dbeafe, transparent 40%),
          radial-gradient(circle at 100% 0%, #bfdbfe, transparent 36%), var(--bg);
        font-family: "Hiragino Kaku Gothic ProN", "Yu Gothic", "Noto Sans JP", sans-serif;
      }

      button,
      input {
        font: inherit;
      }

      .app {
        height: 100%;
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .topbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 10px;
        border-bottom: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(4px);
      }

      .topbar button,
      .topbar label {
        border: 1px solid transparent;
        border-radius: 10px;
        padding: 8px 12px;
        color: #fff;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        cursor: pointer;
        font-weight: 700;
      }

      .topbar label {
        display: inline-flex;
        align-items: center;
      }

      .topbar button:focus-visible,
      .topbar label:focus-visible {
        outline: 3px solid #7dd3fc;
        outline-offset: 2px;
      }

      #fileInput {
        display: none;
      }

      .status {
        margin-left: auto;
        color: var(--muted);
        align-self: center;
        font-size: 0.92rem;
      }

      .main {
        min-height: 0;
        display: grid;
        grid-template-columns: minmax(280px, 40%) 1fr;
      }

      .left,
      .right {
        min-height: 0;
      }

      .left {
        border-right: 1px solid var(--line);
        background: var(--surface);
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .dropzone {
        margin: 10px;
        padding: 10px;
        border: 2px dashed #7dd3fc;
        border-radius: 12px;
        color: #0c4a6e;
        background: #ecfeff;
        font-size: 0.9rem;
      }

      .dropzone.drag {
        background: #cffafe;
        border-color: #0284c7;
      }

      .tree-wrap {
        min-height: 0;
        overflow: auto;
        position: relative;
      }

      .tree-spacer {
        position: relative;
      }

      .row {
        position: absolute;
        left: 0;
        right: 0;
        height: var(--row-h);
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 0 8px;
        border-bottom: 1px solid #f1f5f9;
        user-select: none;
        background: transparent;
      }

      .row[aria-selected="true"] {
        background: #e0f2fe;
      }

      .row.drop-before {
        box-shadow: inset 0 2px 0 #0284c7;
      }

      .row.drop-after {
        box-shadow: inset 0 -2px 0 #0284c7;
      }

      .row.drop-inside {
        background: #dbeafe;
      }

      .expander {
        border: 0;
        background: transparent;
        color: #0f172a;
        width: 22px;
        height: 22px;
        border-radius: 6px;
        cursor: pointer;
      }

      .expander:focus-visible,
      .row:focus-visible,
      .urlbar input:focus-visible,
      .urlbar button:focus-visible {
        outline: 3px solid #7dd3fc;
        outline-offset: 1px;
      }

      .fav {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        object-fit: cover;
        background: #e2e8f0;
      }

      .name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .right {
        display: grid;
        grid-template-rows: auto 1fr auto;
        background: rgba(255, 255, 255, 0.75);
      }

      .urlbar {
        border-bottom: 1px solid var(--line);
        padding: 8px;
        display: flex;
        gap: 8px;
      }

      .urlbar input {
        flex: 1;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        min-width: 0;
      }

      .urlbar button {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        cursor: pointer;
      }

      .viewer {
        min-height: 0;
        position: relative;
      }

      iframe {
        width: 100%;
        height: 100%;
        border: 0;
        background: #fff;
      }

      .fallback {
        position: absolute;
        inset: 0;
        padding: 18px;
        display: none;
        align-items: center;
        justify-content: center;
        text-align: center;
        background: linear-gradient(180deg, #f8fafc, #f1f5f9);
      }

      .fallback.show {
        display: flex;
      }

      .fallback a {
        color: #0369a1;
        font-weight: 700;
      }

      .meta {
        padding: 8px 10px;
        border-top: 1px solid var(--line);
        color: var(--muted);
        font-size: 0.9rem;
      }

      .ctx {
        position: fixed;
        z-index: 50;
        min-width: 160px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.16);
        padding: 4px;
        display: none;
      }

      .ctx.show {
        display: block;
      }

      .ctx button {
        width: 100%;
        text-align: left;
        background: transparent;
        border: 0;
        border-radius: 8px;
        padding: 8px;
        cursor: pointer;
      }

      .ctx button:hover {
        background: #e2e8f0;
      }

      @media (max-width: 900px) {
        .main {
          grid-template-columns: 1fr;
          grid-template-rows: minmax(260px, 48%) 1fr;
        }

        .left {
          border-right: 0;
          border-bottom: 1px solid var(--line);
        }

        .status {
          width: 100%;
          margin-left: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="topbar" aria-label="操作メニュー">
        <label for="fileInput" id="importLabel">インポート</label>
        <input id="fileInput" type="file" accept=".html,text/html" />
        <button id="exportBtn" type="button">エクスポート</button>
        <button id="addCurrentBtn" type="button">追加（★新規）</button>
        <div class="status" id="status" aria-live="polite">準備完了</div>
      </header>

      <div class="main">
        <section class="left" aria-label="ブックマークツリー">
          <div class="dropzone" id="dropzone">ここにHTMLをドロップ、または「インポート」から選択</div>
          <div class="tree-wrap" id="treeWrap" role="tree" aria-label="ブックマーク一覧">
            <div class="tree-spacer" id="treeSpacer"></div>
          </div>
        </section>

        <section class="right" aria-label="ページ表示">
          <div class="urlbar">
            <input id="urlInput" type="url" placeholder="https://example.com" aria-label="表示URL" />
            <button id="openBtn" type="button">表示</button>
            <button id="openTabBtn" type="button">新規タブ</button>
          </div>
          <div class="viewer" id="viewer">
            <iframe id="frame" title="ページ表示エリア" referrerpolicy="no-referrer"></iframe>
            <div id="fallback" class="fallback" aria-live="polite">
              <div>
                <p>このページは埋め込み表示できません。</p>
                <p><a id="fallbackLink" href="#" target="_blank" rel="noopener noreferrer">新規タブで開く</a></p>
              </div>
            </div>
          </div>
          <div class="meta" id="meta">URL: (未選択)</div>
        </section>
      </div>
    </div>

    <div id="ctx" class="ctx" role="menu" aria-label="項目メニュー"></div>

    <script>
      (() => {
        "use strict";

        const state = {
          root: { id: "root", type: "folder", name: "root", addDate: nowSec(), children: [] },
          expanded: new Set(["root"]),
          selectedId: null,
          visibleRows: [],
          index: new Map(),
          currentUrl: "",
          currentTitle: "",
          currentFavicon: "",
          drag: null,
          dropHint: null,
          longPressTimer: null,
          contextTargetId: null,
          idSeed: 1
        };

        const supportsDnD = "draggable" in document.createElement("div");
        const supportsPointer = "PointerEvent" in window;
        const isCoarsePointer = typeof window.matchMedia === "function" && window.matchMedia("(pointer: coarse)").matches;
        const canEmbedFile = location.protocol !== "file:";

        const els = {
          fileInput: document.getElementById("fileInput"),
          importLabel: document.getElementById("importLabel"),
          exportBtn: document.getElementById("exportBtn"),
          addCurrentBtn: document.getElementById("addCurrentBtn"),
          status: document.getElementById("status"),
          dropzone: document.getElementById("dropzone"),
          treeWrap: document.getElementById("treeWrap"),
          treeSpacer: document.getElementById("treeSpacer"),
          urlInput: document.getElementById("urlInput"),
          openBtn: document.getElementById("openBtn"),
          openTabBtn: document.getElementById("openTabBtn"),
          frame: document.getElementById("frame"),
          fallback: document.getElementById("fallback"),
          fallbackLink: document.getElementById("fallbackLink"),
          meta: document.getElementById("meta"),
          ctx: document.getElementById("ctx")
        };

        function nowSec() {
          return Math.floor(Date.now() / 1000).toString();
        }

        function setStatus(msg) {
          els.status.textContent = msg;
        }

        function newId() {
          state.idSeed += 1;
          return "n" + state.idSeed;
        }

        function escHtml(v) {
          return String(v)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;");
        }

        function normalizeUrl(raw) {
          const t = (raw || "").trim();
          if (!t) return "";
          try {
            return new URL(t).href;
          } catch (_) {
            try {
              return new URL("https://" + t).href;
            } catch (_) {
              return "";
            }
          }
        }

        function faviconFromUrl(url) {
          try {
            const u = new URL(url);
            return u.origin + "/favicon.ico";
          } catch (_) {
            return "";
          }
        }

        function rebuildIndex() {
          state.index.clear();
          walk(state.root, null, 0);

          function walk(node, parentId, depth) {
            state.index.set(node.id, { node, parentId, depth });
            if (node.type === "folder") {
              node.children.forEach((child) => walk(child, node.id, depth + 1));
            }
          }
        }

        function flattenVisible() {
          const list = [];
          const rowH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--row-h")) || 34;

          const walk = (node, depth) => {
            if (node.id !== "root") {
              list.push({
                id: node.id,
                node,
                depth,
                isFolder: node.type === "folder",
                expanded: state.expanded.has(node.id)
              });
            }
            if (node.type === "folder" && state.expanded.has(node.id)) {
              for (const child of node.children) walk(child, depth + (node.id === "root" ? 0 : 1));
            }
          };

          walk(state.root, 0);
          state.visibleRows = list;
          els.treeSpacer.style.height = list.length * rowH + "px";
        }

        function renderTree() {
          flattenVisible();
          renderVisibleWindow();
        }

        function renderVisibleWindow() {
          const list = state.visibleRows;
          const rowH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--row-h")) || 34;
          const viewportH = els.treeWrap.clientHeight || 300;
          const scrollTop = els.treeWrap.scrollTop;
          const start = Math.max(0, Math.floor(scrollTop / rowH) - 8);
          const end = Math.min(list.length, Math.ceil((scrollTop + viewportH) / rowH) + 8);
          const frag = document.createDocumentFragment();

          for (let i = start; i < end; i += 1) {
            frag.appendChild(createRow(list[i], i, rowH));
          }

          els.treeSpacer.innerHTML = "";
          els.treeSpacer.appendChild(frag);
        }

        function createRow(row, i, rowH) {
          const el = document.createElement("div");
          el.className = "row";
          el.setAttribute("role", "treeitem");
          el.setAttribute("aria-level", String(row.depth + 1));
          el.setAttribute("aria-selected", String(state.selectedId === row.id));
          el.tabIndex = 0;
          el.style.top = i * rowH + "px";
          el.style.paddingLeft = 8 + row.depth * 18 + "px";
          el.dataset.id = row.id;

          if (state.dropHint && state.dropHint.targetId === row.id) {
            el.classList.add("drop-" + state.dropHint.mode);
          }

          if (row.isFolder) {
            const exp = document.createElement("button");
            exp.type = "button";
            exp.className = "expander";
            exp.setAttribute("aria-label", row.expanded ? "フォルダを閉じる" : "フォルダを開く");
            exp.textContent = row.expanded ? "▾" : "▸";
            exp.addEventListener("click", (e) => {
              e.stopPropagation();
              toggleFolder(row.id);
            });
            el.appendChild(exp);
          } else {
            const spacer = document.createElement("span");
            spacer.style.width = "22px";
            el.appendChild(spacer);
          }

          const icon = document.createElement("img");
          icon.className = "fav";
          const iconSrc = row.node.favicon || (row.node.url ? faviconFromUrl(row.node.url) : "");
          if (iconSrc) icon.src = iconSrc;
          icon.alt = "";
          icon.onerror = () => {
            icon.onerror = null;
            icon.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Crect width='16' height='16' rx='2' fill='%23cbd5e1'/%3E%3Cpath d='M4 5h8v2H4zm0 4h6v2H4z' fill='%23475569'/%3E%3C/svg%3E";
          };
          el.appendChild(icon);

          const name = document.createElement("span");
          name.className = "name";
          name.textContent = row.node.name || row.node.url || "(無題)";
          el.appendChild(name);

          el.addEventListener("click", () => handleRowClick(row.id));
          el.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            showContextMenu(row.id, e.clientX, e.clientY);
          });

          attachLongPress(el, row.id);

          if (supportsDnD) {
            el.draggable = true;
            el.addEventListener("dragstart", (e) => {
              state.drag = { sourceId: row.id };
              e.dataTransfer.effectAllowed = "move";
              e.dataTransfer.setData("text/plain", row.id);
            });
            el.addEventListener("dragover", (e) => {
              e.preventDefault();
              updateDropHint(e, row, el);
            });
            el.addEventListener("dragleave", () => {
              state.dropHint = null;
              renderVisibleWindow();
            });
            el.addEventListener("drop", (e) => {
              e.preventDefault();
              performDrop(row.id, e, el);
            });
          }

          return el;
        }

        function attachLongPress(el, id) {
          const start = (ev) => {
            if (ev.type === "mousedown" && ev.button !== 0) return;
            clearTimeout(state.longPressTimer);
            state.longPressTimer = setTimeout(() => {
              const p = pointFromEvent(ev);
              showContextMenu(id, p.x, p.y);
            }, 480);
          };

          const cancel = () => clearTimeout(state.longPressTimer);

          if (supportsPointer) {
            el.addEventListener("pointerdown", start);
            el.addEventListener("pointerup", cancel);
            el.addEventListener("pointercancel", cancel);
            el.addEventListener("pointermove", cancel);
          } else {
            el.addEventListener("touchstart", start, { passive: true });
            el.addEventListener("touchend", cancel);
            el.addEventListener("touchcancel", cancel);
            el.addEventListener("mousedown", start);
            el.addEventListener("mouseup", cancel);
            el.addEventListener("mouseleave", cancel);
          }
        }

        function pointFromEvent(ev) {
          if (ev.touches && ev.touches[0]) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
          return { x: ev.clientX || 10, y: ev.clientY || 10 };
        }

        function toggleFolder(id) {
          if (state.expanded.has(id)) state.expanded.delete(id);
          else state.expanded.add(id);
          renderTree();
        }

        function handleRowClick(id) {
          const rec = state.index.get(id);
          if (!rec) return;
          state.selectedId = id;
          if (rec.node.type === "folder") {
            toggleFolder(id);
            return;
          }
          showUrl(rec.node.url || "", rec.node.name || "", rec.node.favicon || "", true);
          renderVisibleWindow();
        }

        function showUrl(url, title, favicon, fromBookmarkClick) {
          const normalized = normalizeUrl(url);
          if (!normalized) {
            setStatus("URL形式が不正です");
            return;
          }
          state.currentUrl = normalized;
          state.currentTitle = title || "";
          state.currentFavicon = favicon || faviconFromUrl(normalized);
          els.urlInput.value = normalized;
          els.meta.textContent = "URL: " + normalized;
          els.fallbackLink.href = normalized;

          if (!canEmbedFile) {
            setFallback(true);
            setStatus("file://環境のためリンク表示モード");
            return;
          }

          setFallback(false);
          els.frame.src = normalized;
          if (fromBookmarkClick) {
            setStatus("ブックマークを表示しました");
          }

          const timeoutId = setTimeout(() => {
            setFallback(true);
            setStatus("埋め込み不可の可能性があるためリンク表示に切替");
          }, 4500);

          const onLoad = () => {
            clearTimeout(timeoutId);
            try {
              const loc = els.frame.contentWindow.location.href;
              if (loc && /^https?:/i.test(loc)) {
                state.currentUrl = loc;
                els.urlInput.value = loc;
                els.meta.textContent = "URL: " + loc;
                els.fallbackLink.href = loc;
              }
              const docTitle = els.frame.contentDocument.title;
              if (docTitle) state.currentTitle = docTitle;
              setFallback(false);
            } catch (_) {
              setFallback(true);
            }
          };

          els.frame.onload = onLoad;
        }

        function setFallback(show) {
          els.fallback.classList.toggle("show", show);
        }

        async function addCurrentPageToTop() {
          const url = normalizeUrl(els.urlInput.value || state.currentUrl);
          if (!url) {
            setStatus("追加対象URLがありません");
            return;
          }

          const meta = await resolveCurrentMeta(url);
          const node = {
            id: newId(),
            type: "bookmark",
            name: meta.title || url,
            url,
            favicon: meta.favicon || faviconFromUrl(url),
            addDate: nowSec()
          };

          state.root.children.unshift(node);
          rebuildIndex();
          renderTree();
          setStatus("最上位に追加しました: " + node.name);
        }

        async function resolveCurrentMeta(url) {
          let title = "";
          let favicon = state.currentFavicon || faviconFromUrl(url);

          if (state.currentUrl === url && state.currentTitle) {
            title = state.currentTitle;
          }

          if (!title && canEmbedFile) {
            try {
              const sameOrigin = new URL(url).origin === location.origin;
              if (sameOrigin && els.frame.contentDocument) {
                title = els.frame.contentDocument.title || "";
                const iconEl = els.frame.contentDocument.querySelector("link[rel~='icon']");
                if (iconEl && iconEl.href) favicon = new URL(iconEl.href, url).href;
              }
            } catch (_) {
              // ignore
            }
          }

          if (!title) {
            try {
              const res = await fetch(url, { method: "GET", mode: "cors" });
              if (res.ok) {
                const html = await res.text();
                const m = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
                if (m && m[1]) title = m[1].trim().replace(/\s+/g, " ");
                const iconMatch = html.match(/<link[^>]*rel=["'][^"']*icon[^"']*["'][^>]*href=["']([^"']+)["']/i);
                if (iconMatch && iconMatch[1]) {
                  favicon = new URL(iconMatch[1], url).href;
                }
              }
            } catch (_) {
              // CORSなどで失敗したらフォールバック
            }
          }

          return { title: title || url, favicon };
        }

        function parseBookmarkHtml(text) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(text, "text/html");
          const rootDl = doc.querySelector("DL");
          if (!rootDl) throw new Error("Bookmark HTMLのDL要素が見つかりません");

          const parseDl = (dl) => {
            const items = [];
            const children = Array.from(dl.children);

            for (let i = 0; i < children.length; i += 1) {
              const child = children[i];
              if (child.tagName !== "DT") continue;

              const direct = Array.from(child.children);
              const h3 = direct.find((n) => n.tagName === "H3");
              const a = direct.find((n) => n.tagName === "A");

              if (h3) {
                const folder = {
                  id: newId(),
                  type: "folder",
                  name: h3.textContent ? h3.textContent.trim() : "(無題フォルダ)",
                  addDate: h3.getAttribute("ADD_DATE") || nowSec(),
                  children: []
                };

                let next = child.nextElementSibling;
                if (!next) {
                  const inDtDl = direct.find((n) => n.tagName === "DL");
                  if (inDtDl) next = inDtDl;
                }
                if (next && next.tagName === "DL") {
                  folder.children = parseDl(next);
                }

                items.push(folder);
                continue;
              }

              if (a) {
                const url = a.getAttribute("HREF") || "";
                items.push({
                  id: newId(),
                  type: "bookmark",
                  name: (a.textContent || url || "(無題)").trim(),
                  url,
                  favicon: a.getAttribute("ICON") || faviconFromUrl(url),
                  addDate: a.getAttribute("ADD_DATE") || nowSec()
                });
              }
            }

            return items;
          };

          return parseDl(rootDl);
        }

        function exportBookmarkHtml() {
          const lines = [];
          lines.push("<!DOCTYPE NETSCAPE-Bookmark-file-1>");
          lines.push('<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">');
          lines.push("<TITLE>Bookmarks</TITLE>");
          lines.push("<H1>Bookmarks</H1>");
          lines.push("<DL><p>");

          const emit = (node, depth) => {
            const pad = "    ".repeat(depth);
            if (node.type === "folder") {
              lines.push(
                `${pad}<DT><H3 ADD_DATE="${escHtml(node.addDate || nowSec())}">${escHtml(node.name || "(無題フォルダ)")}</H3>`
              );
              lines.push(`${pad}<DL><p>`);
              node.children.forEach((c) => emit(c, depth + 1));
              lines.push(`${pad}</DL><p>`);
              return;
            }

            const attrs = [`HREF="${escHtml(node.url || "")}"`, `ADD_DATE="${escHtml(node.addDate || nowSec())}"`];
            if (node.favicon) attrs.push(`ICON="${escHtml(node.favicon)}"`);
            lines.push(`${pad}<DT><A ${attrs.join(" ")}>${escHtml(node.name || node.url || "(無題)")}</A>`);
          };

          state.root.children.forEach((n) => emit(n, 1));
          lines.push("</DL><p>");
          return lines.join("\n");
        }

        function findParentAndIndex(id, node = state.root) {
          if (node.type !== "folder") return null;
          const idx = node.children.findIndex((n) => n.id === id);
          if (idx >= 0) return { parent: node, index: idx };
          for (const child of node.children) {
            if (child.type === "folder") {
              const found = findParentAndIndex(id, child);
              if (found) return found;
            }
          }
          return null;
        }

        function isDescendant(folderId, checkId) {
          const root = state.index.get(folderId)?.node;
          if (!root || root.type !== "folder") return false;
          const stack = [...root.children];
          while (stack.length) {
            const n = stack.pop();
            if (n.id === checkId) return true;
            if (n.type === "folder") stack.push(...n.children);
          }
          return false;
        }

        function updateDropHint(e, row, rowEl) {
          const rect = rowEl.getBoundingClientRect();
          const y = e.clientY - rect.top;
          let mode = "after";
          if (y < rect.height * 0.25) mode = "before";
          else if (y > rect.height * 0.75) mode = "after";
          else if (row.isFolder) mode = "inside";

          state.dropHint = { targetId: row.id, mode };
          renderVisibleWindow();
        }

        function performDrop(targetId, e, rowEl) {
          const sourceId = state.drag ? state.drag.sourceId : e.dataTransfer.getData("text/plain");
          state.drag = null;
          if (!sourceId || sourceId === targetId) return;

          const sourceRef = findParentAndIndex(sourceId);
          const targetRef = findParentAndIndex(targetId);
          if (!sourceRef || !targetRef) return;

          const sourceNode = sourceRef.parent.children[sourceRef.index];
          const targetNode = targetRef.parent.children[targetRef.index];
          const rect = rowEl.getBoundingClientRect();
          const y = e.clientY - rect.top;
          let mode = "after";
          if (y < rect.height * 0.25) mode = "before";
          else if (y > rect.height * 0.75) mode = "after";
          else if (targetNode.type === "folder") mode = "inside";

          if (sourceNode.type === "folder" && mode === "inside" && isDescendant(sourceNode.id, targetNode.id)) {
            setStatus("フォルダ配下へ自分自身は移動できません");
            return;
          }

          sourceRef.parent.children.splice(sourceRef.index, 1);

          if (mode === "inside" && targetNode.type === "folder") {
            targetNode.children.unshift(sourceNode);
            state.expanded.add(targetNode.id);
          } else {
            const parent = targetRef.parent;
            const adjustedIndex = parent.children.findIndex((n) => n.id === targetNode.id);
            const insertAt = mode === "before" ? adjustedIndex : adjustedIndex + 1;
            parent.children.splice(insertAt, 0, sourceNode);
          }

          state.dropHint = null;
          rebuildIndex();
          renderTree();
          setStatus("並び替えを更新しました");
        }

        function showContextMenu(id, x, y) {
          state.contextTargetId = id;
          const rec = state.index.get(id);
          if (!rec) return;

          const baseActions = [
            { label: "名前変更", fn: renameItem },
            { label: "削除", fn: deleteItem },
            { label: "上へ移動", fn: moveItemUp },
            { label: "下へ移動", fn: moveItemDown }
          ];

          const createActions = [
            { label: "新規URL", fn: (targetId) => createUrlUnder(resolveTargetFolder(targetId)) },
            { label: "新規フォルダ", fn: (targetId) => createFolderUnder(resolveTargetFolder(targetId)) }
          ];

          const actions = [...createActions, ...baseActions];

          els.ctx.innerHTML = "";
          actions.forEach((a) => {
            const b = document.createElement("button");
            b.type = "button";
            b.textContent = a.label;
            b.addEventListener("click", () => {
              hideContextMenu();
              a.fn(id);
            });
            els.ctx.appendChild(b);
          });

          els.ctx.style.left = Math.min(x, window.innerWidth - 180) + "px";
          els.ctx.style.top = Math.min(y, window.innerHeight - 220) + "px";
          els.ctx.classList.add("show");
        }

        function resolveTargetFolder(targetId) {
          const rec = state.index.get(targetId);
          if (!rec) return "root";
          if (rec.node.type === "folder") return targetId;
          return rec.parentId || "root";
        }

        function moveItemUp(id) {
          const ref = findParentAndIndex(id);
          if (!ref || ref.index <= 0) return;
          const arr = ref.parent.children;
          [arr[ref.index - 1], arr[ref.index]] = [arr[ref.index], arr[ref.index - 1]];
          rebuildIndex();
          renderTree();
          setStatus("上へ移動しました");
        }

        function moveItemDown(id) {
          const ref = findParentAndIndex(id);
          if (!ref || ref.index >= ref.parent.children.length - 1) return;
          const arr = ref.parent.children;
          [arr[ref.index], arr[ref.index + 1]] = [arr[ref.index + 1], arr[ref.index]];
          rebuildIndex();
          renderTree();
          setStatus("下へ移動しました");
        }

        function hideContextMenu() {
          els.ctx.classList.remove("show");
          state.contextTargetId = null;
        }

        function renameItem(id) {
          const rec = state.index.get(id);
          if (!rec) return;
          const next = window.prompt("新しい名前", rec.node.name || "");
          if (next == null) return;
          rec.node.name = next.trim() || rec.node.name;
          renderTree();
          setStatus("名前を変更しました");
        }

        function deleteItem(id) {
          const rec = findParentAndIndex(id);
          if (!rec) return;
          const node = rec.parent.children[rec.index];
          const ok = window.confirm(`削除しますか: ${node.name || node.url}`);
          if (!ok) return;
          rec.parent.children.splice(rec.index, 1);
          if (state.selectedId === id) state.selectedId = null;
          rebuildIndex();
          renderTree();
          setStatus("削除しました");
        }

        function createUrlUnder(folderId) {
          const rec = state.index.get(folderId);
          if (!rec || rec.node.type !== "folder") return;
          const raw = window.prompt("URLを入力", "https://");
          if (!raw) return;
          const url = normalizeUrl(raw);
          if (!url) {
            setStatus("URLが不正です");
            return;
          }
          const title = window.prompt("タイトル", url) || url;
          rec.node.children.unshift({
            id: newId(),
            type: "bookmark",
            name: title,
            url,
            favicon: faviconFromUrl(url),
            addDate: nowSec()
          });
          state.expanded.add(folderId);
          rebuildIndex();
          renderTree();
          setStatus("URLを追加しました");
        }

        function createFolderUnder(folderId) {
          const rec = state.index.get(folderId);
          if (!rec || rec.node.type !== "folder") return;
          const name = window.prompt("フォルダ名", "新規フォルダ");
          if (!name) return;
          rec.node.children.unshift({ id: newId(), type: "folder", name: name.trim(), addDate: nowSec(), children: [] });
          state.expanded.add(folderId);
          rebuildIndex();
          renderTree();
          setStatus("フォルダを追加しました");
        }

        async function handleImportText(text) {
          try {
            const imported = parseBookmarkHtml(text);
            state.root.children = imported;
            state.expanded = new Set(["root"]);
            state.selectedId = null;
            state.currentUrl = "";
            state.currentTitle = "";
            state.currentFavicon = "";
            rebuildIndex();
            renderTree();
            setStatus(`インポート完了: ${imported.length} 件`);
          } catch (err) {
            console.error(err);
            setStatus("インポート失敗: " + (err.message || "不明なエラー"));
          }
        }

        function bindImport() {
          if (isCoarsePointer) {
            els.dropzone.textContent = "モバイル環境: 「インポート」をタップして選択";
          }

          els.fileInput.addEventListener("change", async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            const text = await file.text();
            handleImportText(text);
            e.target.value = "";
          });

          const useDrop = supportsPointer || "ontouchstart" in window || "ondragenter" in window;
          if (!useDrop) {
            els.dropzone.textContent = "インポートボタンからファイルを選択してください";
            return;
          }

          const prevent = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
          };

          ["dragenter", "dragover"].forEach((type) => {
            els.dropzone.addEventListener(type, (ev) => {
              prevent(ev);
              els.dropzone.classList.add("drag");
            });
          });

          ["dragleave", "drop"].forEach((type) => {
            els.dropzone.addEventListener(type, (ev) => {
              prevent(ev);
              els.dropzone.classList.remove("drag");
            });
          });

          els.dropzone.addEventListener("drop", async (ev) => {
            const file = ev.dataTransfer && ev.dataTransfer.files && ev.dataTransfer.files[0];
            if (!file) return;
            const text = await file.text();
            handleImportText(text);
          });
        }

        function bindExport() {
          els.exportBtn.addEventListener("click", () => {
            try {
              const html = exportBookmarkHtml();
              const blob = new Blob([html], { type: "text/html;charset=utf-8" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "bookmarks_export.html";
              a.click();
              URL.revokeObjectURL(url);
              setStatus("エクスポートしました");
            } catch (err) {
              console.error(err);
              setStatus("エクスポート失敗");
            }
          });
        }

        function bindViewer() {
          els.openBtn.addEventListener("click", () => {
            const url = normalizeUrl(els.urlInput.value);
            if (!url) {
              setStatus("URL形式が不正です");
              return;
            }
            showUrl(url, "", "", false);
            setStatus("URLを表示しました");
          });

          els.urlInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") els.openBtn.click();
          });

          els.openTabBtn.addEventListener("click", () => {
            const url = normalizeUrl(els.urlInput.value || state.currentUrl);
            if (!url) {
              setStatus("URLがありません");
              return;
            }
            window.open(url, "_blank", "noopener,noreferrer");
          });

          els.frame.addEventListener("load", () => {
            try {
              const doc = els.frame.contentDocument;
              if (!doc) return;
              const title = doc.title || "";
              if (title) state.currentTitle = title;

              const links = doc.querySelectorAll("a[href]");
              links.forEach((a) => {
                a.addEventListener("click", () => {
                  try {
                    const href = new URL(a.getAttribute("href"), state.currentUrl || els.frame.contentWindow.location.href).href;
                    state.currentUrl = href;
                    els.urlInput.value = href;
                    els.meta.textContent = "URL: " + href;
                    els.fallbackLink.href = href;
                  } catch (_) {
                    // ignore
                  }
                });
              });
            } catch (_) {
              // cross-originはアクセス不可
            }
          });
        }

        function bindContextClose() {
          document.addEventListener("click", (e) => {
            if (!els.ctx.contains(e.target)) hideContextMenu();
          });
          window.addEventListener("scroll", hideContextMenu, true);
          window.addEventListener("resize", hideContextMenu);
        }

        function bindTreeScroll() {
          els.treeWrap.addEventListener("scroll", renderVisibleWindow, { passive: true });
        }

        function seedSample() {
          state.root.children = [
            {
              id: newId(),
              type: "folder",
              name: "サンプル",
              addDate: nowSec(),
              children: [
                {
                  id: newId(),
                  type: "bookmark",
                  name: "MDN Web Docs",
                  url: "https://developer.mozilla.org/",
                  favicon: "https://developer.mozilla.org/favicon-48x48.cbbd161b.png",
                  addDate: nowSec()
                }
              ]
            }
          ];
          state.expanded.add(state.root.children[0].id);
        }

        function bootstrap() {
          seedSample();
          rebuildIndex();
          renderTree();
          bindTreeScroll();
          bindImport();
          bindExport();
          bindViewer();
          bindContextClose();
          els.addCurrentBtn.addEventListener("click", addCurrentPageToTop);
          setStatus("準備完了: インポートしてください");
        }

        bootstrap();
      })();
    </script>
  </body>
</html>
