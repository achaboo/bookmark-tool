<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bookmark Tree Manager</title>
    <style>
      :root {
        --bg: #f3f6fb;
        --panel: #ffffff;
        --line: #cbd5e1;
        --text: #0f172a;
        --muted: #64748b;
        --accent: #0369a1;
        --accent-soft: #dbeafe;
        --danger: #b91c1c;
        --row-h: 38px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        background: radial-gradient(circle at 15% -20%, #dbeafe 0%, transparent 38%),
          radial-gradient(circle at 100% 0%, #bfdbfe 0%, transparent 30%), var(--bg);
        color: var(--text);
        font-family: "Hiragino Kaku Gothic ProN", "Yu Gothic", "Noto Sans JP", sans-serif;
      }

      button,
      input,
      select {
        font: inherit;
      }

      .app {
        height: 100%;
        display: grid;
        grid-template-rows: auto auto auto 1fr auto;
      }

      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 10px;
        border-bottom: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(5px);
      }

      .toolbar button,
      .toolbar label {
        border: 1px solid transparent;
        border-radius: 10px;
        padding: 8px 12px;
        font-weight: 700;
        color: #fff;
        background: linear-gradient(135deg, #0284c7, #0ea5e9);
        cursor: pointer;
      }

      .toolbar button.secondary {
        background: #334155;
      }

      .toolbar button:focus-visible,
      .toolbar label:focus-visible,
      .search input:focus-visible,
      .bulk select:focus-visible,
      .bulk button:focus-visible,
      .row:focus-visible,
      .expander:focus-visible,
      .ctx button:focus-visible {
        outline: 3px solid #7dd3fc;
        outline-offset: 2px;
      }

      #fileInput {
        display: none;
      }

      .search {
        padding: 8px 10px;
        border-bottom: 1px solid var(--line);
        background: #ffffff;
      }

      .search input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px 12px;
      }

      .bulk {
        position: sticky;
        top: 0;
        z-index: 10;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-bottom: 1px solid var(--line);
        background: #ecfeff;
      }

      .bulk.show {
        display: flex;
      }

      .bulk .count {
        font-weight: 700;
        color: #0c4a6e;
      }

      .bulk select {
        min-width: 200px;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 7px;
      }

      .bulk button {
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 7px 10px;
        background: #fff;
        cursor: pointer;
      }

      .bulk button.danger {
        color: #fff;
        background: var(--danger);
        border-color: #991b1b;
      }

      .tree-pane {
        min-height: 0;
        margin: 10px;
        border: 1px solid var(--line);
        border-radius: 14px;
        overflow: hidden;
        background: var(--panel);
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .dropzone {
        padding: 9px 10px;
        border-bottom: 1px solid var(--line);
        color: #0c4a6e;
        font-size: 0.9rem;
        background: #f0f9ff;
      }

      .dropzone.drag {
        background: #cffafe;
      }

      .tree-wrap {
        min-height: 0;
        overflow: auto;
        position: relative;
      }

      .tree-spacer {
        position: relative;
      }

      .row {
        position: absolute;
        left: 0;
        right: 0;
        height: var(--row-h);
        display: flex;
        align-items: center;
        gap: 7px;
        border-bottom: 1px solid #eef2f7;
        padding: 0 8px;
        cursor: default;
      }

      .row.selected {
        background: #e0f2fe;
      }

      .row.drop-before {
        box-shadow: inset 0 2px 0 #0284c7;
      }

      .row.drop-after {
        box-shadow: inset 0 -2px 0 #0284c7;
      }

      .row.drop-inside {
        background: var(--accent-soft);
      }

      .expander {
        border: 0;
        width: 20px;
        height: 20px;
        border-radius: 6px;
        background: transparent;
        cursor: pointer;
        color: #1e293b;
      }

      .check {
        width: 16px;
        height: 16px;
      }

      .icon {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        object-fit: cover;
        background: #e2e8f0;
      }

      .name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
      }

      .badge {
        color: var(--muted);
        font-size: 0.75rem;
        margin-left: auto;
      }

      .status {
        border-top: 1px solid var(--line);
        background: #fff;
        color: var(--muted);
        padding: 8px 10px;
        font-size: 0.9rem;
      }

      .ctx {
        position: fixed;
        min-width: 170px;
        z-index: 40;
        background: #fff;
        border: 1px solid var(--line);
        border-radius: 10px;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.18);
        padding: 4px;
        display: none;
      }

      .ctx.show {
        display: block;
      }

      .ctx button {
        width: 100%;
        border: 0;
        border-radius: 8px;
        padding: 8px;
        text-align: left;
        background: transparent;
        cursor: pointer;
      }

      .ctx button:hover {
        background: #e2e8f0;
      }

      @media (max-width: 720px) {
        .bulk {
          flex-wrap: wrap;
        }

        .bulk select {
          min-width: 0;
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="toolbar" aria-label="操作ボタン">
        <label for="fileInput">インポート</label>
        <input id="fileInput" type="file" accept=".html,text/html" />
        <button id="exportBtn" type="button">エクスポート</button>
        <button id="collapseBtn" class="secondary" type="button">すべて折りたたみ</button>
        <button id="expandBtn" class="secondary" type="button">すべて展開</button>
      </header>

      <section class="search">
        <input id="searchInput" type="search" placeholder="検索（タイトル / URL / フォルダ名）" aria-label="検索" />
      </section>

      <section id="bulkBar" class="bulk" aria-label="複数選択操作">
        <span class="count" id="selectedCount">0件選択</span>
        <button id="bulkDeleteBtn" class="danger" type="button">削除</button>
        <select id="moveTargetSelect" aria-label="移動先フォルダ"></select>
        <button id="bulkMoveBtn" type="button">移動</button>
        <button id="clearSelectionBtn" type="button">選択解除</button>
      </section>

      <section class="tree-pane" aria-label="ブックマークツリー">
        <div id="dropzone" class="dropzone">ここにブックマークHTMLをドロップ、またはインポートを使用</div>
        <div id="treeWrap" class="tree-wrap" role="tree" aria-label="ブックマーク一覧">
          <div id="treeSpacer" class="tree-spacer"></div>
        </div>
      </section>

      <footer id="status" class="status" aria-live="polite">準備完了</footer>
    </div>

    <div id="ctx" class="ctx" role="menu" aria-label="コンテキストメニュー"></div>

    <script>
      (() => {
        "use strict";

        const state = {
          root: { id: "root", type: "folder", name: "root", addDate: nowSec(), children: [] },
          index: new Map(),
          expanded: new Set(["root"]),
          visibleRows: [],
          selectedIds: new Set(),
          lastSelectedId: null,
          query: "",
          drag: null,
          dropHint: null,
          longPressTimer: null,
          idSeq: 1
        };

        const supportsDnD = "draggable" in document.createElement("div");
        const supportsPointer = "PointerEvent" in window;
        const isCoarsePointer = typeof window.matchMedia === "function" && window.matchMedia("(pointer: coarse)").matches;

        const els = {
          fileInput: document.getElementById("fileInput"),
          exportBtn: document.getElementById("exportBtn"),
          collapseBtn: document.getElementById("collapseBtn"),
          expandBtn: document.getElementById("expandBtn"),
          searchInput: document.getElementById("searchInput"),
          bulkBar: document.getElementById("bulkBar"),
          selectedCount: document.getElementById("selectedCount"),
          bulkDeleteBtn: document.getElementById("bulkDeleteBtn"),
          moveTargetSelect: document.getElementById("moveTargetSelect"),
          bulkMoveBtn: document.getElementById("bulkMoveBtn"),
          clearSelectionBtn: document.getElementById("clearSelectionBtn"),
          dropzone: document.getElementById("dropzone"),
          treeWrap: document.getElementById("treeWrap"),
          treeSpacer: document.getElementById("treeSpacer"),
          status: document.getElementById("status"),
          ctx: document.getElementById("ctx")
        };

        function nowSec() {
          return Math.floor(Date.now() / 1000).toString();
        }

        function setStatus(message) {
          els.status.textContent = message;
        }

        function newId() {
          state.idSeq += 1;
          return "n" + state.idSeq;
        }

        function normalizeUrl(raw) {
          const t = (raw || "").trim();
          if (!t) return "";
          try {
            return new URL(t).href;
          } catch (_) {
            try {
              return new URL("https://" + t).href;
            } catch (_) {
              return "";
            }
          }
        }

        function faviconFromUrl(url) {
          try {
            const u = new URL(url);
            return u.origin + "/favicon.ico";
          } catch (_) {
            return "";
          }
        }

        function escapeHtml(v) {
          return String(v)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;");
        }

        function rebuildIndex() {
          state.index.clear();
          walk(state.root, null, 0);

          function walk(node, parentId, depth) {
            state.index.set(node.id, { node, parentId, depth });
            if (node.type === "folder") {
              node.children.forEach((child) => walk(child, node.id, depth + 1));
            }
          }
        }

        function buildVisibleRows() {
          const rows = [];
          const q = state.query.trim().toLowerCase();
          const forceSearchMode = q.length > 0;
          const includeMap = new Map();
          const ownMap = new Map();

          if (forceSearchMode) {
            const mark = (node, ancestorsMatched) => {
              const text = node.type === "bookmark" ? `${node.name} ${node.url}` : node.name;
              const ownMatched = text.toLowerCase().includes(q);
              let childMatched = false;
              if (node.type === "folder") {
                for (const child of node.children) {
                  if (mark(child, ancestorsMatched || ownMatched)) childMatched = true;
                }
              }
              const include = ownMatched || childMatched || ancestorsMatched;
              includeMap.set(node.id, include);
              ownMap.set(node.id, ownMatched);
              return include;
            };
            mark(state.root, false);
          }

          const walk = (node, depth) => {
            if (node.id !== "root") {
              if (forceSearchMode && !includeMap.get(node.id)) return;
              rows.push({
                id: node.id,
                node,
                depth,
                ownMatched: !!ownMap.get(node.id)
              });
            }

            const open =
              node.type === "folder" &&
              (forceSearchMode ? true : state.expanded.has(node.id));
            if (!open) return;

            for (const child of node.children) {
              walk(child, depth + (node.id === "root" ? 0 : 1));
            }
          };

          walk(state.root, 0);
          state.visibleRows = rows;

          const rowH = getRowHeight();
          els.treeSpacer.style.height = rows.length * rowH + "px";
        }

        function getRowHeight() {
          return parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--row-h")) || 38;
        }

        function renderTree() {
          buildVisibleRows();
          renderViewport();
          updateSelectionUI();
        }

        function renderViewport() {
          const rows = state.visibleRows;
          const rowH = getRowHeight();
          const viewportH = els.treeWrap.clientHeight || 400;
          const scrollTop = els.treeWrap.scrollTop;
          const start = Math.max(0, Math.floor(scrollTop / rowH) - 8);
          const end = Math.min(rows.length, Math.ceil((scrollTop + viewportH) / rowH) + 8);

          const frag = document.createDocumentFragment();
          for (let i = start; i < end; i += 1) {
            frag.appendChild(createRowElement(rows[i], i, rowH));
          }

          els.treeSpacer.innerHTML = "";
          els.treeSpacer.appendChild(frag);
        }

        function createRowElement(row, i, rowH) {
          const node = row.node;
          const el = document.createElement("div");
          el.className = "row";
          if (state.selectedIds.has(row.id)) el.classList.add("selected");
          if (state.dropHint && state.dropHint.targetId === row.id) {
            el.classList.add("drop-" + state.dropHint.mode);
          }
          el.style.top = i * rowH + "px";
          el.style.paddingLeft = 8 + row.depth * 18 + "px";
          el.tabIndex = 0;
          el.dataset.id = row.id;
          el.setAttribute("role", "treeitem");
          el.setAttribute("aria-level", String(row.depth + 1));
          if (node.type === "folder") {
            el.setAttribute("aria-expanded", String(state.expanded.has(row.id)));
          }

          if (node.type === "folder") {
            const expander = document.createElement("button");
            expander.type = "button";
            expander.className = "expander";
            expander.textContent = state.expanded.has(row.id) ? "▾" : "▸";
            expander.setAttribute("aria-label", state.expanded.has(row.id) ? "フォルダを閉じる" : "フォルダを開く");
            expander.addEventListener("click", (e) => {
              e.stopPropagation();
              toggleFolder(row.id);
            });
            el.appendChild(expander);
          } else {
            const spacer = document.createElement("span");
            spacer.style.width = "20px";
            el.appendChild(spacer);
          }

          const check = document.createElement("input");
          check.type = "checkbox";
          check.className = "check";
          check.checked = state.selectedIds.has(row.id);
          check.setAttribute("aria-label", "選択");
          check.addEventListener("click", (e) => {
            e.stopPropagation();
            handleSelectionGesture(row.id, i, e);
          });
          el.appendChild(check);

          const icon = document.createElement("img");
          icon.className = "icon";
          if (node.type === "folder") {
            icon.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Crect x='1' y='3' width='14' height='11' rx='2' fill='%23f59e0b'/%3E%3Cpath d='M2 4h4l1 1h7v2H2z' fill='%23fcd34d'/%3E%3C/svg%3E";
          } else {
            icon.src = node.favicon || faviconFromUrl(node.url || "");
            icon.onerror = () => {
              icon.onerror = null;
              icon.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Crect width='16' height='16' rx='2' fill='%23cbd5e1'/%3E%3Cpath d='M4 5h8v2H4zm0 4h6v2H4z' fill='%23475569'/%3E%3C/svg%3E";
            };
          }
          icon.alt = "";
          el.appendChild(icon);

          const name = document.createElement("span");
          name.className = "name";
          name.textContent = node.name || node.url || "(無題)";
          if (row.ownMatched) name.style.fontWeight = "800";
          el.appendChild(name);

          if (node.type === "folder") {
            const badge = document.createElement("span");
            badge.className = "badge";
            badge.textContent = String(node.children.length);
            el.appendChild(badge);
          }

          el.addEventListener("click", (e) => {
            handleSelectionGesture(row.id, i, e);
            if (node.type === "folder") {
              if (!e.shiftKey && !e.ctrlKey && !e.metaKey) toggleFolder(row.id);
              return;
            }
            if (!e.shiftKey && !e.ctrlKey && !e.metaKey) {
              openBookmarkInBackground(node.url);
            }
          });

          el.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            showContextMenu(row.id, e.clientX, e.clientY);
          });

          attachLongPress(el, row.id);
          attachDragEvents(el, row);

          return el;
        }

        function attachLongPress(el, id) {
          const start = (ev) => {
            if (ev.type === "mousedown" && ev.button !== 0) return;
            clearTimeout(state.longPressTimer);
            state.longPressTimer = setTimeout(() => {
              const p = eventPoint(ev);
              showContextMenu(id, p.x, p.y);
            }, 460);
          };
          const cancel = () => clearTimeout(state.longPressTimer);

          if (supportsPointer) {
            el.addEventListener("pointerdown", start);
            el.addEventListener("pointerup", cancel);
            el.addEventListener("pointercancel", cancel);
            el.addEventListener("pointermove", cancel);
          } else {
            el.addEventListener("touchstart", start, { passive: true });
            el.addEventListener("touchend", cancel);
            el.addEventListener("touchcancel", cancel);
            el.addEventListener("mousedown", start);
            el.addEventListener("mouseup", cancel);
            el.addEventListener("mouseleave", cancel);
          }
        }

        function eventPoint(ev) {
          if (ev.touches && ev.touches[0]) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
          return { x: ev.clientX || 12, y: ev.clientY || 12 };
        }

        function attachDragEvents(el, row) {
          if (!supportsDnD) return;

          el.draggable = true;
          el.addEventListener("dragstart", (e) => {
            state.drag = { sourceId: row.id };
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", row.id);
          });

          el.addEventListener("dragover", (e) => {
            e.preventDefault();
            const rect = el.getBoundingClientRect();
            const y = e.clientY - rect.top;
            let mode = "after";
            if (y < rect.height * 0.25) mode = "before";
            else if (y > rect.height * 0.75) mode = "after";
            else if (row.node.type === "folder") mode = "inside";
            state.dropHint = { targetId: row.id, mode };
            renderViewport();
          });

          el.addEventListener("dragleave", () => {
            state.dropHint = null;
            renderViewport();
          });

          el.addEventListener("drop", (e) => {
            e.preventDefault();
            performDrop(row.id, e, el);
          });
        }

        function toggleFolder(id) {
          if (state.expanded.has(id)) state.expanded.delete(id);
          else state.expanded.add(id);
          renderTree();
        }

        function findParentAndIndex(id, cursor = state.root) {
          if (cursor.type !== "folder") return null;
          const idx = cursor.children.findIndex((c) => c.id === id);
          if (idx >= 0) return { parent: cursor, index: idx };
          for (const child of cursor.children) {
            if (child.type === "folder") {
              const result = findParentAndIndex(id, child);
              if (result) return result;
            }
          }
          return null;
        }

        function isDescendant(parentId, targetId) {
          const root = state.index.get(parentId)?.node;
          if (!root || root.type !== "folder") return false;
          const stack = [...root.children];
          while (stack.length) {
            const n = stack.pop();
            if (n.id === targetId) return true;
            if (n.type === "folder") stack.push(...n.children);
          }
          return false;
        }

        function performDrop(targetId, event, rowEl) {
          const sourceId = state.drag ? state.drag.sourceId : event.dataTransfer.getData("text/plain");
          state.drag = null;
          if (!sourceId || sourceId === targetId) return;

          const sourceRef = findParentAndIndex(sourceId);
          const targetRef = findParentAndIndex(targetId);
          if (!sourceRef || !targetRef) return;

          const sourceNode = sourceRef.parent.children[sourceRef.index];
          const targetNode = targetRef.parent.children[targetRef.index];
          const rect = rowEl.getBoundingClientRect();
          const y = event.clientY - rect.top;
          let mode = "after";
          if (y < rect.height * 0.25) mode = "before";
          else if (y > rect.height * 0.75) mode = "after";
          else if (targetNode.type === "folder") mode = "inside";

          if (sourceNode.type === "folder" && mode === "inside" && isDescendant(sourceNode.id, targetNode.id)) {
            setStatus("自分自身の子孫へは移動できません");
            return;
          }

          sourceRef.parent.children.splice(sourceRef.index, 1);

          if (mode === "inside" && targetNode.type === "folder") {
            targetNode.children.unshift(sourceNode);
            state.expanded.add(targetNode.id);
          } else {
            const siblings = targetRef.parent.children;
            const targetNow = siblings.findIndex((n) => n.id === targetNode.id);
            const insertAt = mode === "before" ? targetNow : targetNow + 1;
            siblings.splice(insertAt, 0, sourceNode);
          }

          state.dropHint = null;
          rebuildIndex();
          renderTree();
          setStatus("並び替えを更新しました");
        }

        function handleSelectionGesture(id, rowIndex, event) {
          const withRange = event.shiftKey;
          const withToggle = event.ctrlKey || event.metaKey;

          if (withRange && state.lastSelectedId) {
            const start = state.visibleRows.findIndex((r) => r.id === state.lastSelectedId);
            const end = rowIndex;
            if (start >= 0) {
              const [a, b] = start < end ? [start, end] : [end, start];
              for (let i = a; i <= b; i += 1) {
                state.selectedIds.add(state.visibleRows[i].id);
              }
            } else {
              state.selectedIds.add(id);
            }
          } else if (withToggle) {
            if (state.selectedIds.has(id)) state.selectedIds.delete(id);
            else state.selectedIds.add(id);
          } else {
            state.selectedIds.clear();
            state.selectedIds.add(id);
          }

          state.lastSelectedId = id;
          renderViewport();
          updateSelectionUI();
        }

        function clearSelection() {
          state.selectedIds.clear();
          state.lastSelectedId = null;
          renderViewport();
          updateSelectionUI();
        }

        function updateSelectionUI() {
          const count = state.selectedIds.size;
          els.selectedCount.textContent = `${count}件選択`;
          els.bulkDeleteBtn.disabled = count === 0;
          els.bulkMoveBtn.disabled = count === 0;
          refreshMoveTargets();
        }

        function openBookmarkInBackground(url) {
          try {
            window.open(url, "_blank", "noopener,noreferrer");
            setTimeout(() => {
              try {
                window.focus();
              } catch (_) {
                // ignore focus errors
              }
            }, 0);
            setStatus("新規タブで開きました（ブラウザ仕様により前面維持できない場合があります）: " + url);
          } catch (err) {
            console.error(err);
            setStatus("タブを開けませんでした: " + url);
          }
        }

        function refreshMoveTargets() {
          const folders = [];
          collectFolders(state.root, "root");

          function collectFolders(node, path) {
            if (node.type !== "folder") return;
            folders.push({ id: node.id, label: path === "root" ? "最上位" : path });
            node.children.forEach((c) => {
              if (c.type === "folder") {
                const nextPath = path === "root" ? c.name : `${path} / ${c.name}`;
                collectFolders(c, nextPath);
              }
            });
          }

          const current = els.moveTargetSelect.value;
          els.moveTargetSelect.innerHTML = "";
          folders.forEach((f) => {
            const op = document.createElement("option");
            op.value = f.id;
            op.textContent = f.label;
            els.moveTargetSelect.appendChild(op);
          });

          if (folders.some((f) => f.id === current)) {
            els.moveTargetSelect.value = current;
          }
        }

        function bulkDelete() {
          if (state.selectedIds.size === 0) return;
          if (!window.confirm(`${state.selectedIds.size}件を削除しますか？`)) return;

          const ids = Array.from(state.selectedIds);
          ids.forEach((id) => {
            const ref = findParentAndIndex(id);
            if (ref) ref.parent.children.splice(ref.index, 1);
          });

          clearSelection();
          rebuildIndex();
          renderTree();
          setStatus("選択項目を削除しました");
        }

        function bulkMove() {
          if (state.selectedIds.size === 0) return;
          const targetId = els.moveTargetSelect.value;
          const targetRec = state.index.get(targetId);
          if (!targetRec || targetRec.node.type !== "folder") {
            setStatus("移動先フォルダが不正です");
            return;
          }

          const ids = Array.from(state.selectedIds);
          const moving = [];

          for (const id of ids) {
            const ref = findParentAndIndex(id);
            if (!ref) continue;
            const node = ref.parent.children[ref.index];
            if (node.type === "folder" && (node.id === targetId || isDescendant(node.id, targetId))) {
              continue;
            }
            ref.parent.children.splice(ref.index, 1);
            moving.push(node);
          }

          if (!moving.length) {
            setStatus("移動可能な項目がありません");
            return;
          }

          targetRec.node.children.unshift(...moving);
          state.expanded.add(targetId);
          clearSelection();
          rebuildIndex();
          renderTree();
          setStatus(`${moving.length}件を移動しました`);
        }

        function renameItem(id) {
          const rec = state.index.get(id);
          if (!rec) return;
          const next = window.prompt("新しい名前", rec.node.name || "");
          if (next == null) return;
          rec.node.name = next.trim() || rec.node.name;
          rebuildIndex();
          renderTree();
          setStatus("名前を変更しました");
        }

        function deleteSingle(id) {
          const ref = findParentAndIndex(id);
          if (!ref) return;
          const node = ref.parent.children[ref.index];
          if (!window.confirm(`削除しますか: ${node.name || node.url}`)) return;
          ref.parent.children.splice(ref.index, 1);
          state.selectedIds.delete(id);
          rebuildIndex();
          renderTree();
          setStatus("削除しました");
        }

        function resolveTargetFolder(id) {
          const rec = state.index.get(id);
          if (!rec) return "root";
          if (rec.node.type === "folder") return id;
          return rec.parentId || "root";
        }

        function createUrl(targetId) {
          const folderId = resolveTargetFolder(targetId);
          const rec = state.index.get(folderId);
          if (!rec || rec.node.type !== "folder") return;
          const raw = window.prompt("URL", "https://");
          if (!raw) return;
          const url = normalizeUrl(raw);
          if (!url) {
            setStatus("URLが不正です");
            return;
          }
          const title = window.prompt("タイトル", url) || url;
          rec.node.children.unshift({
            id: newId(),
            type: "bookmark",
            name: title,
            url,
            favicon: faviconFromUrl(url),
            addDate: nowSec()
          });
          state.expanded.add(folderId);
          rebuildIndex();
          renderTree();
          setStatus("URLを追加しました");
        }

        function createFolder(targetId) {
          const folderId = resolveTargetFolder(targetId);
          const rec = state.index.get(folderId);
          if (!rec || rec.node.type !== "folder") return;
          const name = window.prompt("フォルダ名", "新規フォルダ");
          if (!name) return;
          rec.node.children.unshift({ id: newId(), type: "folder", name: name.trim(), addDate: nowSec(), children: [] });
          state.expanded.add(folderId);
          rebuildIndex();
          renderTree();
          setStatus("フォルダを追加しました");
        }

        function showContextMenu(id, x, y) {
          const actions = [
            { label: "名前変更", fn: renameItem },
            { label: "削除", fn: deleteSingle },
            { label: "新規 URL", fn: createUrl },
            { label: "新規フォルダ", fn: createFolder }
          ];

          els.ctx.innerHTML = "";
          actions.forEach((action) => {
            const b = document.createElement("button");
            b.type = "button";
            b.textContent = action.label;
            b.addEventListener("click", () => {
              hideContextMenu();
              action.fn(id);
            });
            els.ctx.appendChild(b);
          });

          els.ctx.style.left = Math.min(x, window.innerWidth - 190) + "px";
          els.ctx.style.top = Math.min(y, window.innerHeight - 220) + "px";
          els.ctx.classList.add("show");
        }

        function hideContextMenu() {
          els.ctx.classList.remove("show");
        }

        function parseBookmarkHtml(text) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(text, "text/html");
          const rootDl = doc.querySelector("DL");
          if (!rootDl) throw new Error("Bookmark HTMLのDL要素が見つかりません");

          const parseDl = (dl) => {
            const out = [];
            const children = Array.from(dl.children);
            for (let i = 0; i < children.length; i += 1) {
              const el = children[i];
              if (el.tagName !== "DT") continue;

              const direct = Array.from(el.children);
              const h3 = direct.find((n) => n.tagName === "H3");
              const a = direct.find((n) => n.tagName === "A");

              if (h3) {
                const folder = {
                  id: newId(),
                  type: "folder",
                  name: (h3.textContent || "(無題フォルダ)").trim(),
                  addDate: h3.getAttribute("ADD_DATE") || nowSec(),
                  children: []
                };

                let nestedDl = el.nextElementSibling;
                if (!nestedDl) nestedDl = direct.find((n) => n.tagName === "DL");
                if (nestedDl && nestedDl.tagName === "DL") {
                  folder.children = parseDl(nestedDl);
                }
                out.push(folder);
                continue;
              }

              if (a) {
                const url = a.getAttribute("HREF") || "";
                out.push({
                  id: newId(),
                  type: "bookmark",
                  name: (a.textContent || url || "(無題)").trim(),
                  url,
                  favicon: a.getAttribute("ICON") || faviconFromUrl(url),
                  addDate: a.getAttribute("ADD_DATE") || nowSec()
                });
              }
            }
            return out;
          };

          return parseDl(rootDl);
        }

        function exportBookmarkHtml() {
          const lines = [];
          lines.push("<!DOCTYPE NETSCAPE-Bookmark-file-1>");
          lines.push('<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">');
          lines.push("<TITLE>Bookmarks</TITLE>");
          lines.push("<H1>Bookmarks</H1>");
          lines.push("<DL><p>");

          const emit = (node, depth) => {
            const pad = "    ".repeat(depth);
            if (node.type === "folder") {
              lines.push(`${pad}<DT><H3 ADD_DATE="${escapeHtml(node.addDate || nowSec())}">${escapeHtml(node.name || "(無題フォルダ)")}</H3>`);
              lines.push(`${pad}<DL><p>`);
              node.children.forEach((child) => emit(child, depth + 1));
              lines.push(`${pad}</DL><p>`);
              return;
            }

            const attrs = [`HREF="${escapeHtml(node.url || "")}"`, `ADD_DATE="${escapeHtml(node.addDate || nowSec())}"`];
            if (node.favicon) attrs.push(`ICON="${escapeHtml(node.favicon)}"`);
            lines.push(`${pad}<DT><A ${attrs.join(" ")}>${escapeHtml(node.name || node.url || "(無題)")}</A>`);
          };

          state.root.children.forEach((child) => emit(child, 1));
          lines.push("</DL><p>");
          return lines.join("\n");
        }

        async function handleImportFile(file) {
          try {
            const text = await file.text();
            state.root.children = parseBookmarkHtml(text);
            state.expanded = new Set(["root"]);
            state.selectedIds.clear();
            state.lastSelectedId = null;
            rebuildIndex();
            renderTree();
            setStatus(`インポート完了: ${state.visibleRows.length}件表示`);
          } catch (err) {
            console.error(err);
            setStatus("インポート失敗: " + (err.message || "不明なエラー"));
          }
        }

        function bindImport() {
          if (isCoarsePointer) {
            els.dropzone.textContent = "モバイル環境: インポートボタンからファイルを選択";
          }

          els.fileInput.addEventListener("change", async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            await handleImportFile(file);
            e.target.value = "";
          });

          const prevent = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
          };

          ["dragenter", "dragover"].forEach((type) => {
            els.dropzone.addEventListener(type, (ev) => {
              prevent(ev);
              els.dropzone.classList.add("drag");
            });
          });

          ["dragleave", "drop"].forEach((type) => {
            els.dropzone.addEventListener(type, (ev) => {
              prevent(ev);
              els.dropzone.classList.remove("drag");
            });
          });

          els.dropzone.addEventListener("drop", async (ev) => {
            const file = ev.dataTransfer && ev.dataTransfer.files && ev.dataTransfer.files[0];
            if (!file) return;
            await handleImportFile(file);
          });
        }

        function bindSearch() {
          let timer = null;
          els.searchInput.addEventListener("input", () => {
            clearTimeout(timer);
            timer = setTimeout(() => {
              state.query = els.searchInput.value || "";
              renderTree();
              setStatus(state.query ? `検索: "${state.query}"` : "検索をクリアしました");
            }, 300);
          });
        }

        function bindBulkActions() {
          els.bulkDeleteBtn.addEventListener("click", bulkDelete);
          els.bulkMoveBtn.addEventListener("click", bulkMove);
          els.clearSelectionBtn.addEventListener("click", clearSelection);
        }

        function bindToolbar() {
          els.exportBtn.addEventListener("click", () => {
            try {
              const html = exportBookmarkHtml();
              const blob = new Blob([html], { type: "text/html;charset=utf-8" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "bookmarks_export.html";
              a.click();
              URL.revokeObjectURL(url);
              setStatus("エクスポートしました");
            } catch (err) {
              console.error(err);
              setStatus("エクスポート失敗");
            }
          });

          els.collapseBtn.addEventListener("click", () => {
            state.expanded.clear();
            state.expanded.add("root");
            renderTree();
            setStatus("すべて折りたたみました");
          });

          els.expandBtn.addEventListener("click", () => {
            state.index.forEach((rec, id) => {
              if (rec.node.type === "folder") state.expanded.add(id);
            });
            renderTree();
            setStatus("すべて展開しました");
          });
        }

        function bindGlobalEvents() {
          els.treeWrap.addEventListener("scroll", renderViewport, { passive: true });
          document.addEventListener("click", (e) => {
            if (!els.ctx.contains(e.target)) hideContextMenu();
          });
          window.addEventListener("resize", hideContextMenu);
          window.addEventListener("scroll", hideContextMenu, true);
        }

        function seed() {
          state.root.children = [
            {
              id: newId(),
              type: "folder",
              name: "サンプル",
              addDate: nowSec(),
              children: [
                {
                  id: newId(),
                  type: "bookmark",
                  name: "MDN",
                  url: "https://developer.mozilla.org/",
                  favicon: "https://developer.mozilla.org/favicon-48x48.cbbd161b.png",
                  addDate: nowSec()
                },
                {
                  id: newId(),
                  type: "bookmark",
                  name: "WHATWG",
                  url: "https://whatwg.org/",
                  favicon: "https://whatwg.org/favicon.ico",
                  addDate: nowSec()
                }
              ]
            }
          ];
          state.expanded.add(state.root.children[0].id);
        }

        function bootstrap() {
          seed();
          rebuildIndex();
          renderTree();
          bindImport();
          bindSearch();
          bindBulkActions();
          bindToolbar();
          bindGlobalEvents();
          if (!supportsDnD) setStatus("DnD非対応環境です。メニュー操作をご利用ください");
        }

        bootstrap();
      })();
    </script>
  </body>
</html>
